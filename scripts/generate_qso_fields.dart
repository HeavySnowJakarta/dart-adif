// This script generates classes of supported QSO fields according to given
// information of the CSV table.

// TODO: Add support for getting original data.

import 'dart:io';

// Convert ADIF type to Dart type in strings.
const typeDict = {
  'Boolean': 'bool',
  'Integer': 'int',
  'PostiveInteger': 'int',
  'Number': 'double',
  'Date': 'DateTime',
  'Time': 'DateTime',
  'String': 'String',
  'IntlString': 'String',
  'MultilineString': 'String',
  'IntlMultilineString': 'String',
};

// Convert the string from UPPER_SNAKE_CASE to UpperCamelCase.
String toUpperCamelCase(String str) {
  return str
      .split('_')
      .map((part) => part[0].toUpperCase() + part.substring(1).toLowerCase())
      .join('');
}

void main() {
  // Open the files.
  final inputFile = File('qso_fields.csv');
  final implement = File('../lib/src/qso_fields/fields_auto.dart');
  final factories = File('../lib/src/qso_fields/factory_auto.dart');

  // Read from the source.
  print("Generating Dart codes of QSO fields...");
  print("Reading the CSV file...");
  final String inputContent = inputFile.readAsStringSync();

  // Generate the target string.
  String implementContent = """
/// The implements of ADIF-defined QSO fields, generated by
/// `scripts/generate_qso_fields.dart`. Don't edit this file by hand.
library;

import '../data.dart';
import '../data_types/index.dart';

""";
  String factoryContent = """
/// The factory function to generate a ADIF-defined QSO field, generated by
/// `scripts/generate_qso_fields.dart`. Don't edit this file by hand.
library;

import '../data.dart';
import './total.dart';

AdifField adifFieldFactory(String fieldName, String value) {
  switch (fieldName) {
""";

  // Parse fields from the read data.
  for (final line in inputContent.trim().split('\n')) {
    // Skip comments.
    if (line[0] == '#') {
      continue;
    }

    // Parse the fields.
    final parts = line.split('|');
    final fieldNameUpperSnake = parts[0].trim();
    final fieldType = parts[1].trim();
    final fieldDescription = parts[2].trim();
    final fieldNameUpperCamel = toUpperCamelCase(fieldNameUpperSnake);

    // Write to the implement file.
    implementContent += """
/// $fieldDescription
class Adif$fieldNameUpperCamel extends AdifField {
  final Adif$fieldType value;

  Adif$fieldNameUpperCamel(this.value) : super('$fieldNameUpperSnake');

  @override
  String getString() {
    return value.getString();
  }

  static Adif$fieldNameUpperCamel fromString(String str) {
    return Adif$fieldNameUpperCamel(Adif$fieldType.fromString(str));
  }
}

""";

    factoryContent += """
    case '$fieldNameUpperSnake':
      return Adif$fieldNameUpperCamel.fromString(value);
""";
  }

  // Finish the target strings.
  factoryContent += """
    default:
      throw ArgumentError('Unknown field name: \$fieldName');
  }
}
""";

  // Create the target files.
  print("Reading and parsing finished. Now writing...");
  if (!implement.existsSync()) {
    implement.createSync();
  }
  if (!factories.existsSync()) {
    factories.createSync();
  }

  // Write to the files.
  implement.writeAsStringSync(implementContent);
  factories.writeAsStringSync(factoryContent);

  print("Everything finished.");
}
